class SatelliteManager {
    constructor(scene, dataFetcher) {
        this.scene = scene;
        this.dataFetcher = dataFetcher;
        this.satellites = new Map();
        this.orbitPaths = new Map();
        this.showOrbits = true;
        this.showLabels = false;
        this.processingErrors = 0;
        this.labels = new Map();
    }

    async loadSatellites() {
        const loadingElement = document.getElementById('loading');
        if (loadingElement) {
            loadingElement.style.display = 'block';
            loadingElement.textContent = 'Loading satellite data...';
        }

        try {
            console.log("Loading satellites...");
            const satelliteData = await this.dataFetcher.fetchSatelliteData();
            console.log("Satellite data received:", satelliteData.length, "satellites");
            
            if (satelliteData.length === 0) {
                console.warn("No satellite data received");
                if (loadingElement) {
                    loadingElement.textContent = 'No satellite data available';
                }
                return;
            }
            
            this.createSatellites(satelliteData);
            
            if (loadingElement) {
                loadingElement.style.display = 'none';
            }
            
        } catch (error) {
            console.error('Error loading satellites:', error);
            if (loadingElement) {
                loadingElement.textContent = 'Error loading satellite data';
            }
        }
    }

    createSatellites(satelliteData) {
        console.log("Creating satellites from", satelliteData.length, "data items");
        this.clearSatellites();
        this.processingErrors = 0;

        let createdCount = 0;
        let processedCount = 0;
        
        satelliteData.forEach((satData, index) => {
            if (index > 50) return;

            processedCount++;
            try {
                const satellite = this.createSatelliteObject(satData);
                if (satellite) {
                    const orbitPath = this.createSimpleOrbitPath(satData);
                    
                    this.satellites.set(satData.NORAD_CAT_ID || `sat_${index}`, {
                        object: satellite,
                        data: satData,
                        position: new THREE.Vector3()
                    });

                    if (orbitPath) {
                        this.orbitPaths.set(satData.NORAD_CAT_ID || `sat_${index}`, orbitPath);
                        if (this.showOrbits) {
                            this.scene.add(orbitPath);
                        }
                    }

                    this.scene.add(satellite);
                    createdCount++;
                } else {
                    this.processingErrors++;
                }
            } catch (error) {
                console.error('Error creating satellite at index', index, satData.OBJECT_NAME, ':', error);
                this.processingErrors++;
            }
        });
        
        console.log(`Processed ${processedCount} satellites, created ${createdCount}, errors: ${this.processingErrors}`);
        
        if (this.showLabels && createdCount > 0) {
            setTimeout(() => this.createAllLabels(), 100);
        }
    }

    createSatelliteObject(satData) {
        try {
            if (!satData || !satData.OBJECT_NAME) {
                console.warn('Invalid satellite data');
                return null;
            }

            const geometry = new THREE.SphereGeometry(0.03, 8, 8);
            const color = this.dataFetcher.getColorByCategory(satData.category);
            const material = new THREE.MeshBasicMaterial({ 
                color: color,
                transparent: true,
                opacity: 0.9
            });
            
            const satellite = new THREE.Mesh(geometry, material);
            
            const position = this.calculateRealPosition(satData, new Date());
            if (position) {
                satellite.position.copy(position);
            } else {
                satellite.position.set(1.5, 0, 0);
            }
            
            satellite.userData = { satData: satData };
            
            return satellite;
        } catch (error) {
            console.error('Error creating satellite object for', satData?.OBJECT_NAME, ':', error);
            return null;
        }
    }

    createSimpleOrbitPath(satData) {
        try {
            // Determine orbit characteristics based on category
            let radius, inclination;
            
            switch(satData.category) {
                case 'stations':
                    radius = 1.05; // ISS altitude
                    inclination = 51.6; // ISS inclination
                    break;
                case 'gps':
                    radius = 3.0; // GPS altitude (MEO)
                    inclination = 55; // GPS inclination
                    break;
                case 'weather':
                    radius = 4.0; // Weather satellite altitude
                    inclination = 98; // Sun-synchronous
                    break;
                case 'communications':
                    radius = 1.2; // LEO comms
                    inclination = 45;
                    break;
                default:
                    radius = 1.5 + (Math.random() * 1.5);
                    inclination = 30 + (Math.random() * 60);
            }
            
            const points = [];
            const segments = 64;
            
            for (let i = 0; i <= segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                const rad = radius + (Math.sin(angle * 3) * 0.05); // Slight eccentricity
                const x = Math.cos(angle) * rad;
                const z = Math.sin(angle) * rad;
                const y = Math.sin(inclination * Math.PI / 180) * Math.sin(angle) * 0.3;
                points.push(new THREE.Vector3(x, y, z));
            }
            
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const color = this.dataFetcher.getColorByCategory(satData.category);
            const material = new THREE.LineBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.3
            });
            
            const orbitPath = new THREE.Line(geometry, material);
            orbitPath.visible = this.showOrbits;
            
            return orbitPath;
        } catch (error) {
            console.error('Error creating orbit path:', error);
            return null;
        }
    }

    createAllLabels() {
        console.log("Creating labels...");
        this.clearLabels();
        
        if (!this.showLabels) {
            console.log("Labels disabled");
            return;
        }
        
        let labelCount = 0;
        
        this.satellites.forEach((satInfo, id) => {
            if (satInfo.data && satInfo.data.OBJECT_NAME) {
                try {
                    const labelDiv = document.createElement('div');
                    labelDiv.id = `label-${id}`;
                    labelDiv.textContent = satInfo.data.OBJECT_NAME.substring(0, 20);
                    labelDiv.className = 'satellite-label';
                    labelDiv.style.cssText = `
                        position: absolute;
                        background: rgba(0, 0, 0, 0.8);
                        color: white;
                        padding: 2px 6px;
                        border-radius: 3px;
                        font-size: 10px;
                        pointer-events: none;
                        white-space: nowrap;
                        transform: translate(-50%, -100%);
                        z-index: 1000;
                        border: 1px solid rgba(255, 255, 255, 0.3);
                        display: ${this.showLabels ? 'block' : 'none'};
                    `;
                    
                    document.body.appendChild(labelDiv);
                    this.labels.set(id, labelDiv);
                    labelCount++;
                } catch (error) {
                    console.error('Error creating label:', error);
                }
            }
        });
        
        console.log(`Created ${labelCount} labels`);
    }

    // REAL-TIME ORBITAL CALCULATION
    calculateRealPosition(satData, time) {
        try {
            // Calculate orbital period based on category (in minutes)
            let orbitalPeriodMinutes;
            let baseRadius;
            let inclination;
            
            switch(satData.category) {
                case 'stations': // ISS-like
                    orbitalPeriodMinutes = 90; // 90 minutes per orbit
                    baseRadius = 1.05;
                    inclination = 51.6;
                    break;
                case 'gps': // GPS-like
                    orbitalPeriodMinutes = 720; // 12 hours per orbit
                    baseRadius = 3.0;
                    inclination = 55;
                    break;
                case 'weather': // Weather satellite-like
                    orbitalPeriodMinutes = 100; // Medium orbit
                    baseRadius = 2.5;
                    inclination = 98;
                    break;
                case 'communications': // Comms satellite-like
                    orbitalPeriodMinutes = 95; // LEO comms
                    baseRadius = 1.2;
                    inclination = 45;
                    break;
                default: // Other satellites
                    orbitalPeriodMinutes = 90 + (Math.random() * 300); // 90-390 min
                    baseRadius = 1.5;
                    inclination = 45;
            }
            
            // Convert to milliseconds
            const orbitalPeriodMs = orbitalPeriodMinutes * 60 * 1000;
            
            // Calculate position in orbit (0-1)
            const startTime = new Date(2025, 0, 1).getTime(); // Reference start time
            const elapsedMs = time.getTime() - startTime;
            const orbitProgress = (elapsedMs % orbitalPeriodMs) / orbitalPeriodMs;
            const angle = orbitProgress * Math.PI * 2;
            
            // Calculate 3D position
            const radius = baseRadius + (Math.sin(angle * 2) * 0.02); // Slight eccentricity
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            const y = Math.sin(inclination * Math.PI / 180) * Math.sin(angle * 0.7) * 0.3;
            
            return new THREE.Vector3(x, y, z);
            
        } catch (error) {
            console.error('Error calculating real position:', error);
            return null;
        }
    }

    updatePositions() {
        const now = new Date();
        
        this.satellites.forEach((satInfo, id) => {
            try {
                const position = this.calculateRealPosition(satInfo.data, now);
                if (position && satInfo.object) {
                    satInfo.object.position.copy(position);
                }
            } catch (error) {
                console.error('Error updating position:', error);
            }
        });
    }

    updateLabelPositions(camera, renderer) {
        if (!this.showLabels || this.labels.size === 0) {
            return;
        }

        this.satellites.forEach((satInfo, id) => {
            const label = this.labels.get(id);
            if (label && satInfo.object) {
                try {
                    const vector = satInfo.object.position.clone();
                    vector.project(camera);
                    
                    const container = document.getElementById('container');
                    if (container) {
                        const rect = container.getBoundingClientRect();
                        const x = (vector.x * 0.5 + 0.5) * rect.width + rect.left;
                        const y = (-vector.y * 0.5 + 0.5) * rect.height + rect.top;
                        
                        if (vector.z <= 1 && vector.z >= -1) {
                            label.style.left = `${x}px`;
                            label.style.top = `${y}px`;
                            label.style.display = 'block';
                        } else {
                            label.style.display = 'none';
                        }
                    }
                } catch (error) {
                    if (label) label.style.display = 'none';
                }
            }
        });
    }

    toggleOrbits(show) {
        this.showOrbits = show;
        this.orbitPaths.forEach(orbit => {
            if (orbit) orbit.visible = show;
        });
    }

    toggleLabels(show) {
        console.log("Toggling labels:", show);
        this.showLabels = show;
        
        if (show && this.satellites.size > 0 && this.labels.size === 0) {
            this.createAllLabels();
        }
        
        this.labels.forEach(label => {
            if (label) {
                label.style.display = show ? 'block' : 'none';
            }
        });
    }

    clearLabels() {
        this.labels.forEach((label, id) => {
            if (label && label.parentNode) {
                label.parentNode.removeChild(label);
            }
        });
        this.labels.clear();
    }

    clearSatellites() {
        this.satellites.forEach((satInfo, id) => {
            if (satInfo.object) this.scene.remove(satInfo.object);
        });
        this.orbitPaths.forEach(orbit => {
            if (orbit) this.scene.remove(orbit);
        });
        
        this.clearLabels();
        this.satellites.clear();
        this.orbitPaths.clear();
        this.processingErrors = 0;
    }
    
    // Debug methods
    getSatelliteCount() {
        return this.satellites.size;
    }
    
    getLabelCount() {
        return this.labels.size;
    }
    
    debugInfo() {
        return {
            satellites: this.satellites.size,
            labels: this.labels.size,
            showLabels: this.showLabels,
            showOrbits: this.showOrbits
        };
    }
    
    // Test different orbital speeds
    testOrbitalSpeeds() {
        console.log("=== Orbital Speed Test ===");
        const now = new Date();
        
        // Test one satellite of each type
        this.satellites.forEach((satInfo, id) => {
            if (satInfo.data && satInfo.data.category) {
                const category = satInfo.data.category;
                const position = this.calculateRealPosition(satInfo.data, now);
                console.log(`${category}: Position ${position ? 'calculated' : 'failed'}`);
            }
        });
    }
}
